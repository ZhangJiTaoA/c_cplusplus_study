## 浙大翁恺c语言

#### 1. 计算机如何解决问题。

	- 告诉计算机如何去做。
	- 描述步骤的手段：程序。

#### 2. 计算机懂什么语言

 - 数字：二进制的数字。**通过代码转换过来的。**
 - 计算机--->程序--->算法(计算的步骤)

#### 3. 重复是计算机最擅长的

- c是从b语言发展而来，b语言是从bcpl发展而来，bcpl从FORTRAN发展而来。

#### 4. c语言用在哪里？

- 操作系统
- 嵌入式系统
- 驱动程序
- 底层驱动
  		- 图形引擎，图像处理，声音效果

#### 5. c是一种工业语言

- 开发效率>>学习工程
- 开发效率>>开发乐趣

- 日常应用很少直接用c语言编写，只是练习，不去开发软件。

#### 6. 编译——运行

- 编辑器
- 编译器
- 或将上者结合成IDE（集成开发环境）

- dev-C++

#### 7. 写程序

- 书写框架

- 变量定义

- 变量赋值和初始化（**在c中区别不大，但是在c++中有区别**）
  - 变量在使用前**赋值一次**。
  - 输入：scanf（f:formated格式化）
  
- 常量，const，一定被赋初值。

- 浮点数，不同类型的运算会扩展为占用内存较大的类型

- 表达式

  			- 运算符(operator)：动作，都有返回值。赋值(=)也是一个运算符（a=6这个表达式的返回值为6）。还有复合运算符（+=，*=）。
		
  			- 算子(operand)：值。常数、变量、返回值。

- 只是学习语法是不够的。还要学习在遇到问题时的一般做法：靠阅读，跟着做。

- 0的故事：代码中0内部通常有个杠，因为与o做区分。

- if语句。建议加上{}。常见错误如下：

  			- 忘了加  {}。
		
  			- 多加了  ;
  			- 将==错写为=。
  			- 

- 关系运算。(== != >= > <= <)，会有返回值。优先级小于除赋值运算符外的运算符，**大于赋值运算符**。**(== !=)的优先级**小于其他关系运算符。
- 注释（comment） :  //   /**/  。
- switch-case语句。
  - **直接跳到**应做的代码的位置。
  - switch后的控制表达式只能是**整数**型的结果。
  - case后可以是常数、常量、常数计算的表达式(在编译的时候是知道结果的)。
  - 编译成汇编后是jump table表
- 有些事情就得用循环才能实现。while,do-while,for
  - 如何选择不同的循环语句，
  - 有固定次数的，用for
  - 必须执行一次，用do-while
  - 其他用while
- 数据类型：需要准确地表达计算机里面的东西。
  - c语言的变量，必须：
    - 在使用前定义，并且确定类型
    - 整数：二进制补码的形式。
      - int和long取决于cpu编译器，char(1),short(2),longlong(8);
      - int想要表达的是一个寄存器的大小。
      - unsigned
        - 如果字面量常数为unsigned，则在数字后面加u或U。
        - unsigned的初衷并非用来扩充正数，而是为了做纯二进制计算，为了移位方便。
      - 整数的**输入输出**：int或long long
        - %d:int 
        - %u:unsigned
        - %ld:long long
        - %lu:unsigned long long
      - 0开头：8进制，%o。0x开头：16进制，%x。
      - 整数不能除以0。
      - char也是整数。也是字符（''单引号包裹的东西）。
    - 浮点型：编码的形式。
      - float
        - 字长：32
        - 范围：+-（1.20*10^-38~3.40\*10^38）
      - double
        - 字长：64
      - %f,%e(科学计数法输出)。
      - 正浮点数除以0为inf，正无穷
      - 负浮点数数除以0为-inf，负无穷
      - 0.0/0.0为NAN。
      - 注意精度，计算机里的浮点数无法精确
  - c以后的语言发展方向：
    - c++/java更强调类型，对类型检查更严格
    - javascript,python,php,不强调类型
  - sizeof：是一个运算符，给出某个类型或变量在内存中占据的字节数。
    - 是静态运算符，他的结果在编译的时候就决定了
    - 所以不要在sizeof的括号内进行运算，不会真正执行。
  - 自动类型转换
    - 当运算符两边类型不一样时，自动转为较大的类型
    - 对于printf，任何小于int的类型会被转换为int；float被转为double。
    - 对于scanf来说，不会跟printf一样，如果输入short，需要%hd。scanf需要明确知道输入的类型大小。
  - 强制类型转换
    - 要把一个量强制转为另一个类型（通常是较小的类型）。
    - (类型)值。优先级高于四则运算。
  - 逻辑运算结果bool类型，true、false。
  - 条件运算符？：；。高于赋值运算符，但是低于所有其他运算符。
  - 逗号运算符（，）。会返回右边表达式的结果。主要在for中使用for(i=0,j=10;i<j;i++,j--){}
- 逃逸字符。反斜杠

#### 8. 数组

- 类型  变量名[元素数量];。c99之前数组的大小必须是常数，在编译阶段确定。c99之后可以是变量。
- 一旦创建，不能改变其大小。
- 在内存中数组单元依次排列。
- 下标从0开始。
- 编译器不去检查数组越界。
- sizeof() 可以得到整个数组所占内存的大小（字节）。
- int a[9] = {0},数组a中都是0，int a[9]={8},数组a中第一个为8，剩余为0。就是赋过一个值后，剩余位置均初始化为0。
- 不能简单地进行数组赋值。
- 数组作为参数传递给函数时
  - 不能在[]中给出数组的大小
  - 不能利用sizeof计算数组的元素个数。
- 例子，素数：
  - 除了2，偶数不是素数。
  - 只要循环到sqrt(x)就行了，x的平方根。
  - 判断是否能被已知的素数并且<x,整除,,如果能则不是素数。

- 二维数组。
  - int a[3\][5] ,通常理解为三行五列的矩阵。
  - int a[\][5]={{0,1,2,3,4},{5,6,7,8,9}}。
    - 列数是必须给的，行数可以由编译器来判断
    - 每行一个{}，以逗号隔开。
    - 如果省略，表示补零。
    - 


#### 指针

- 运算符&。获得变量的地址，他的操作数必须是一个变量。

  - %p,会将变量以地址的形式输出。%x，以十六进制形式输出。
  - 地址所占空间的大小取决于64位还是32位。
  - 取地址符的右边必须是明确的变量，不能是表达式。个人理解：明确的变量会在内存中申请空间，而表达式是在程序运行过程中得出的结果。

- 本地变量在堆栈中，分配空间时自顶向下分配的。

- 数组的地址a[]。a==&a，两者都表示a[0]的地址。

- 指针类型：就是保存地址的变量。

  - 指针类型也有地址。。。。。。
  - 访问那个地址上的变量，*p。可以做左值，也可以做右值。
  - 左值为什么叫左值，因为出现在赋值号左边的不是变量，而是值，表示表达式计算的结果。
    - a[0] =2;
    - *p=3;
    - 在左边的是个表达式，其结果能够接收值。a[0]和*p都不是变量，而是表达式。

- 指针的作用。

  - 交换两个变量的值。
  - 将结果从函数中提取出来。
  - 函数返回运算的状态，结果通过指针返回。

- 常见错误：

  - 定义指针变量后，没有赋初值就开始使用。

- 指针和数组。

  - 传入函数的数组成了什么?
    - 在函数里面使用sizeof(数组名)，是一个地址的大小。
    - 就是传入的一个指针。这个指针是第一个元素的地址。
    - 下面四种函数原型是等价的。
      - int sum(int *ar,int n);
      - int sum(int *,int n);
      - int sum(int ar[],int n);
      - int sum(int [],int n);
  - 数组变量是特殊的指针。
    - 数组变量本身表达的是地址。
    - 数组的单元表达的是变量。
    - []运算符可以对数组做，也可以对指针做。
    - *可以对指针做，也可以对数组做。
  - 数组**变量是const的指针，所以不能赋值。**
  - 指针和const
    - int *const q=&i; 指针本身是const。
    - const int *q; 指针所指的对象是const。
    - 总是可以把一个非const转为const。
    - 当要传递的参数的类型比地址大时，这是常用手段。类似于c++中传递引用的功效。
    - 为了保护数组不被函数破坏，可以int sum(const int a[]);
  - 指针运算。
    - 指针加1，则是在地址上加了sizeof(指针所指的类型)。
    - *(p+n)==p[n];
    - *p++;++的优先级大于\*。取出p的数据，p移动到下一个位置。常用于数组类的连续空间。在某些cpu上可以直接翻译为一条汇编指令。
    - 指针比较。
  - 自己琢磨（const变量）如果之后没有用到该const变量的地址，则不给分配地址空间，在预处理解决进行替换，如果后面程序用到了const的地址，则分配地址空间。可能不同编译器不一样而已。。
  - 0地址
    - 内存中有0地址，但是0地址通常是一个不能碰的地址。
      - 操作系统会给每个进程一个虚拟的地址空间，每个进程都以为自己有从0开始的连续空间。
    - 你的指针不能有0值。
    - 因此0地址可以用来表示特殊事情
      - 返回的指针是无效的。
      - 指针没有被真正初始化（先初始化为0）。
    - **NULL是一个预定义**的符号，表示0地址。
      - 有的编译器不希望用0表示0地址。
  - 指针的大小都是一样的。
    - 但是不同类型的指针不要互相赋值。
    - void*表示不知道指向什么的指针。
      - 计算时与char*相同（但不相通）。
    - 指针也可以转换类型。
      - int*p=&i; void *q=(void\*)p;

- 动态内存分配

  - 输入数据时，先告诉个数，然后输入，c99之后了。。
  - int \*a=(int*)malloc(n\*sizeof(int));
  - #include<stdlib.h>
  - 使用malloc申请空间的大小用字节为单位。
  - 返回类型是void*，需要自己进行类型转换。，如果申请失败则返回0或NULL。
  - free()，将申请来的空间归还给系统。
    - 申请的空间都要还。
    - 只能还申请来的首地址。只能还malloc来的空间。
    - free(0),不报错，在初始化指针时赋值给0。
  - 申请了不进行free。
    - 新手：忘了。
    - 老手：找不到合适的free时机。
    - 但是当程序结束后内存都会被清空。

- 字符串:以0结尾的一串字符，0和‘\0'是一样的。

  - 字符数组不是字符串：因为不能用字符串的方式进行计算。

    - char word[]={'h','e','l','l','o','!'};

  - 字符串

    - char word[]={'h','e','l','l','o','!','\0'};

  - string.h

  - 字符串变量

    - char *str="hello";
      - "hello"被放在了一个常量区域。只读，不能改动。
      - 如果两个指针指向同一个字符串，则他们是相同的。
      - 实际是，const char *str="hello";
    - char word[]="hello";
      - 如果要修改字符串，应该用数组，就是这种形式。
      - 会将不可写的内容拷贝到堆栈中（可写区域）。
    - char line[10]="hello";
    - 

  - 字符串常量或字面量

    - “hello”
    - “hello”会被编译器变成一个字符数组放在某处，这个长度为6，结尾是’\0‘。
    - 两个相邻的字符串常量会被自动连接起来。

  - c语言字符串以字符数组的形态存在的。

    - 不能用运算符对字符串做运算。
    - 通过数组的方式遍历字符串。

  - 字符串输入输出。

    - %s,可以用于scanf和printf。
    - scanf读入一个单词（到空格、tab或回车为止）。
    - scanf是不安全的，因为不知道要读入的内容的长度。
      - %7s,表示最多读7个字符。

  - 常见错误。

    - char *string
    - scanf("%s",string);
    - 上面的只是定义了一个字符指针，并且未初始化。

  - 字符串数组。

    - char **a,指向指针的指针。
    - char a[\][10]。每一个a[i]都是一个char [10]。
    - char *a[]。每一个a[i]都是一个 char\*。
    - 程序参数：
      - int main(int argc,char const *argv[])
      - argv[0]是命令本身。执行的时候输入的指令的名字。
      - 当使用Unix的符号链接时，反映符号链接的名字。

  - 字符串函数。

    - int putchar(int c);将一个字符输出到标准输出。返回写了几个字符，EOF(-1)表示失败。
    - int getchar(void);从标准输入读一个字符，返回类型是int为了返回EOF(-1)。
      - window----ctrl-z
      - unix----ctrl-d
    - string.h

    - strlen()。size_t strlen(const char*s);返回s的字符串长度。
    - strcmp()。asIIc码越往后越大。
      - 0：s1==s2
      - 1：s1>s2
      - -1：s1<s2
    - strcpy()。将第二个字符串拷贝到第一个空间里面去。返回第一个字符串。
      - 使用malloc去申请第一个字符串的空间。
    - strcat()。将第二个参数拷贝到第一个的后面，返回第一个参数。尽可能不使用。
      - strncpy()。三个参数，最后加一个n表示剩余的空间大小，最多复制多少。
      - strncat()
      - strncmp()
    - strchr()
    - strstr()

#### 结构类型

- 枚举。
  - 常量符号化，
  - enum 枚举类型的名字{名字0，...，名字n}；是一种类型。
  - 在声明新变量时，使用enum 类型名 变量名。
  - 枚举比宏(macro)好，因为枚举有类型，而宏没有类型。
  - 主要目的是定义符号量。
  - 枚举的空间只占一个；
- 结构类型。
  - 是一条声明语句，需要”；“。类似于函数。
  - 定义变量的时候需要加上struct。
    - 赋初值
      - struct date today = (struct data){7,31,2014};
      - struct date thismonth={.month=7,.year=2014};
      - 没给的值填0
  - struct 名{类型 名；类型 名；}；
  - struct {类型 名；类型 名；}p1，p2；p是变量名。
  - 和数组有点像。
    - 数组用[]访问成员。
    - 结构用 . 访问成员。
    - 结构运算。
      - p1=（struct point）{5，10}；相当于p1.x=5,p1.y=10;
      - p1=p2;   相当于p1.x=p2.x。p1.y=p2.y
    - 但是结构变量的名字不是地址。
  - 结构与函数
    - 结构作为函数的参数。
      - 整个结构可以作为参数的值传递给函数
      - 这时，函数内新建了一个结构变量，并复制调用者传递的结构的值。
      - 也可以返回一个结构。
    - 占用字节数与8对齐（自测）
    - 传入函数时，传递指针。
    - struct date *p=&mydate;  (\*p).month;p->month;
- 自定义数据类型  typedef ：声明一个变量的别名。
  - typedef int Length;  // length成为int的别名。
  - typedef struct AData{} Date;  可以用Date直接声明。

- 联合 union
  - 与struct的类型声明几乎一样。
  - 任何成员变量所占空间只有一份。
  - union能够通过操作得到一个空间的字节。
  - x86小端方式。




#### 程序结构

- __func\_\_:当前函数的名字。

- 全局变量：定义在函数之外的变量，全局的生存期和作用域。
  - 没有初始化的全局变量是0。指针是NULL。
  - 只能用编译时已知的值来初始化全局变量。
  - 初始化在main函数之前。
  - const 可以赋值。
  - 如果函数内部有和全局变量同名的变量，全局变量会被隐藏。
- 静态本地变量
  - 在本地变量定义时加static
  - 函数离开时，静态本地变量会继续存在并保持其值
  - 其初始化只在第一次进行。
  - 其生存期和全局变量一样，但是作用域只在本地。
- 全局变量和静态本地变量的存储区域在一起。
- 返回指针的函数。
  - 返回本地变量的地址是危险的。因为本地变量在离开函数后不存在（那一块内存没有被引了）。
  - 返回全局变量和静态本地变量的地址是安全的。
  - 返回函数内malloc的内存是安全的，但是容易造成问题。
    - 
  - 最好的做法是返回传入的指针。
- 不要使用全局变量在函数内传递参数和结果。
- 尽量避免使用全局变量。
- 使用全局变量和静态本地变量是线程不安全的。
- 宏定义。预处理阶段
  - #开头是编译预处理指令。
  - 不是c语言的成分，
  - #define用来定义一个宏。
    - #define PI 3.14159
    - 预处理的时候进行替换。
  - **不是c的语句**，所以不用加”；“号。可以用在汇编等别的语言。
  - 如果一个宏中有其他宏的名字，也会被替换。
  - 没有值的宏  #define _DEBUG     条件宏。
  - 预定义的宏
    - __LINE\_\_：当前代码的行号。
    - __FILE\_\_：源代码文件的文件名。
    - __DATE\_\_：编译时候的日期
    - __TIME\_\_：编译时候的时间
    - __STDC\_\_：
  - 带参数的宏
    - 比如 # define cube(x) ((x)*(x)\*(x))
    - 都要有括号。
    - 
  - 部分宏会被inline函数替代。
    - 宏没有类型检查，但是inline会有类型检查。
- 多个源代码文件。
  - 没有include函数原型的时候，编译器会猜测使用的函数的各种类型是int。
  - 全局变量可以在多个.c文件共享。
    - **声明**：在.h头文件中进行函数原型的声明，和使用extern进行全局变量的声明。
      - 声明是不产生代码的东西 
      - 只有声明才可以放在头文件中。（规则）
      - 防止头文件被多次引用
        - 标准头文件结构
          - #ifndef _MAX_H\_
          - #define _MAX_H\_
          - xxxxxxxx
          - #endif
  - 在函数前加static使得它只能在所在的编译单元中使用。
  - 在全局变量前加static使得它只能在当前编译单元中使用。
  - 
  - 

​		

#### 文件

- 格式化输入输出
  - printf：返回值是输出的字符数（不是变量数，一个变量有多个字符）。
    - %[flags][width\][.prec\][hlL\]type
  - scanf：其返回值是读了几个变量。
    - %[flag]type
  - 用>和<做重定向
    - 命令行里面用，linux系统dos都行
  - FILE 
    - FILE * fopen(const char* restrict path,const char *restrict mode);
      - r
      - w
      - a
      - 等等。用到的时候查吧。
    - int fclose(FILE *stream);
    - fscanf(FILE*,...);
    - fprintf(FILE*,...);











































































